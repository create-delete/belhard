package by.belhard.java18;
public class Conspect {
}
/*
Worker extends Person
Person p = new Worker();
p.method();
На этапе компиляции смотриться наличие метода в типе, стоящем с лева от ровно. Если нет , то вверх по иерархии.
На этапе выполнения - наличие метода смотриться в правой части и если его там нет - вверх по иерархии
super.method(); - вызов метода именно из класса родителя

При переопределении Equals() надо переопределять и HashCode() потому что те поля, которые используются в equals должны
быть испрользованы и в HashCode()

a instaceOf B вернет true либо false
Вернет тру, если в переменной а содержиться объект класса В или того класса, от которого наследуется В

Все переменые в interface являются final static (константы) и их надо сразу же инициализировать
Все методе в интерфейсах являются абстрактными
private методы в интерфейсах нужны для default методов
Если в классе реализовано 2 интерфейса с 2 дефолными методами с одинаковыми названиями - надо этот метод переопределить в классе

ИНИЦИАЛИЗАЦИЯ
Статические поля и блоки родителя
Статические поля и блоки наследника
Нестатические поля и блоки родителя
Конструктор родителя
Нестатические поля и блоки наследника
Конструктор наследника

ArrayList - удобная обертка для массива. indexOf(Object o) - возвращает индекс переданного объекта. Если такого обекта в списке нет - вернет -1
LinedList - Двусвязный список. new LinkedList - создание ссылки на head списка.
Каждый объект списка содержит 3 поля. Содержимое, ссылка на следующий объект LinkedList и ссылка на предыдуший объект LinkedList
Set - Куча уникальных объектов. Бывают упорядоченные и не упорядоченные.
HashSet - неупорядоченный. TreeSet - на основе красно-черного дерева(хз что это). Это дает мощный инструмент.
Map - набор пар ключ-значение
ArrayList,LinkedList наследуются от интерфейса List



Надо почитать про:
- Enum
- расчеты хэш-кода
- Почему домнажается в методе hashCode результат на 31
- Статический метод в интерфейсе
- Как устроен HashMap


 */